% SIMULATION Top-level simulation script
% Sets up the simulation framework, instantiates objects and contains the main simulation loop.
% Do NOT edit this file, use the simulation_options function instead!
% DO Run this script to start the simulation.
%
% Inputs:
%    (none)
%
% Outputs:
%    Generates the sim_output workspace variable with members:
%    array_inputs - mxN array, where m is the size of the serialized state vector, N is the number of simulation frames
%    array_states - lxN array, where l is the number of vehicle control inputs (commonly 4) and N is the number of
%    simulation frames
%
% Other m-files required: Vehicle, Gravity, Environment, Propulsion, Aerodynamics, Kinematics, VehcileState,
% draw_aircraft, draw_forces, draw_states
% Subfunctions: none
% MAT-files required: none
%
% See also: simulation_options

% Created at 2018/02/15 by George Zogopoulos-Papaliakos

close all;
clear;
clc;

% load_path;

%% Initialize the simulation

fprintf("Initializing simulation options...\n");

% Generate simulation options
sim_options = simulation_options();

% Select model
model_name = sim_options.vehicle;

% Instantiate vehicle
vehicle = Vehicle(model_name);

% Generate the rest of the simulation components
gravity = Gravity(sim_options);
environment = Environment(sim_options);
propulsion = Propulsion(vehicle);
aerodynamics = Aerodynamics(vehicle);
kinematics = Kinematics(sim_options);
vehicle_state_new = VehicleState(); % Use a swap variable to update vehicle state

% If sim_options.controller.type == 1, then the aircraft must be trimmed
if sim_options.controller.type==1
    trimmer = Trimmer(sim_options); % Instantiate the trimming object
    trimmer.calc_trim();
    trim_state = trimmer.get_trim_state(); % Get the trim state
    init_vec_euler = trim_state.get_vec_euler(); % Re-set the initialization state to the trim states
    sim_options.init.vec_euler(1:2) = init_vec_euler(1:2);
    sim_options.init.vec_vel_linear_body = trim_state.get_vec_vel_linear_body();
    sim_options.init.vec_vel_angular_body = trim_state.get_vec_vel_angular_body();
    trim_controls = trimmer.get_trim_controls(); % Get and set the trim controls
    sim_options.controller.static_output = trim_controls;
end

% Initialize vehicle
vehicle.state.initialize(sim_options);

% Generate the controller object
controller = Controller(sim_options);

% Setup time vector
t_0 = sim_options.t_0;
t_f = sim_options.t_f;
dt = sim_options.dt;
t = t_0;
frame_skip = 100;


% Initialize saved signals
num_frames = (t_f-t_0)/dt+1;
if sim_options.record_states
    temp_state = vehicle.state.serialize();
    array_states = zeros(size(temp_state,1),num_frames);
end
if sim_options.record_inputs
    array_inputs = zeros(4,num_frames);
end

% Initialize visualization
if sim_options.visualization.draw_graphics
    draw_aircraft(vehicle, true);    
end
if sim_options.visualization.draw_forces
    plot_forces(gravity, propulsion, aerodynamics, 0, true);    
end
if sim_options.visualization.draw_states
    plot_states(vehicle, 0, true);    
end

%% Begin simulation

fprintf("Starting simulation...\n");

wb_h = waitbar(0, 'Simulation running...');

% Main loop:
frame_num = 1;
tic
while (t<t_f)
    
    % Generate controller output, based on previous state
    ctrl_input = controller.gen_control(vehicle.state);
    
    % Calculate gravity
    gravity.calc_gravity(vehicle);
    vec_gravity_force_body = gravity.get_force_body();
    
    % Calculate environment stuff
    environment.calc_state(vehicle);
    
    % Calculate propulsion
    propulsion.calc_propulsion(vehicle, environment, ctrl_input);
    vec_propulsion_force_body = propulsion.get_force_body();
    vec_propulsion_torque_body = propulsion.get_torque_body();
    
    % Calculate aerodynamics
    aerodynamics.calc_aerodynamics(vehicle, environment, ctrl_input);
    vec_aerodynamics_force_body = aerodynamics.get_force_body();
    vec_aerodynamics_torque_body = aerodynamics.get_torque_body();
    
    % Calculate derivatives
    vec_force_body = vec_gravity_force_body + vec_propulsion_force_body + vec_aerodynamics_force_body;
    vec_torque_body = vec_propulsion_torque_body + vec_aerodynamics_torque_body;    
    kinematics.set_wrench_body(vec_force_body,vec_torque_body);
    
    kinematics.set_state(vehicle.state);
    kinematics.calc_state_derivatives(vehicle);
    
    % Integrate kinematics
    kinematics.integrate();
    
    % Update vehicle state
    kinematics.write_state(vehicle_state_new);
    vehicle.set_state(vehicle_state_new);
    
    % Update waitbar
    if mod(frame_num, frame_skip)==0
        waitbar(frame_num/num_frames, wb_h);
    end
    
    if sim_options.record_states
        array_states(:,frame_num) = vehicle.state.serialize();
    end
    if sim_options.record_inputs
        array_inputs(:,frame_num) = ctrl_input;
    end
    
    % Update visual output
    if sim_options.visualization.draw_graphics
        draw_aircraft(vehicle, false);
    end
    if sim_options.visualization.draw_forces
        plot_forces(gravity, propulsion, aerodynamics, t, false);
    end
    if sim_options.visualization.draw_states
        plot_states(vehicle, t, false);
    end
    
    t = t + dt;
    frame_num = frame_num+1;
    
end
wall_time = toc;

% Close waitbar
close(wb_h);

% Store simulation results to output struct
sim_output.array_inputs = array_inputs;
sim_output.array_states = array_states;


fprintf("Simulation ended\n\n");

fprintf("Simulation duration: %f\n", t_f-t_0);
fprintf("Required wall time: %f\n", wall_time);
fprintf("Achieved speedup ratio: %f\n", (t_f-t_0)/wall_time);

% Clear internal variables
if sim_options.delete_temp_vars
    clear vehicle aerodynamics gravity propulsion kinematics environment controller;
    clear array_inputs array_states vehicle_state_new temp_state ctrl_input
    clear vec_aerodynamics_force_body vec_aerodynamics_torque_body vec_force_body vec_torque_body vec_gravity_force_body vec_propulsion_force_body vec_propulsion_torque_body
    clear dt wall_time t t_0 t_f num_frames frame_num frame_skip wb_h
    clear model_name
end